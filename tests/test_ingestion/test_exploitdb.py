from datetime import datetime, timezone
from unittest.mock import AsyncMock, patch

import httpx

from ingestion.exploitdb import ExploitDBIngestor

_REQ = httpx.Request("GET", "https://test.example.com")


async def _collect(gen):
    results = []
    async for page in gen:
        results.extend(page)
    return results


# ── Sample CSV data ──────────────────────────────────────────────────────

_CSV_HEADER = "id,file,description,date_published,author,platform,type,port"

_CSV_ROWS = [
    "10001,exploits/linux/remote/10001.py,CVE-2025-1111 - Remote Code Execution,2025-01-10,author1,linux,remote,0",
    "10002,exploits/windows/local/10002.py,CVE-2025-2222 - Privilege Escalation,2025-02-01,author2,windows,local,0",
    "10003,exploits/linux/remote/10003.py,No CVE reference here,2025-01-15,author3,linux,remote,0",
    "10004,exploits/multiple/10004.py,CVE-2025-1111 and CVE-2025-3333 - Multi-vuln exploit,2025-02-10,author4,multiple,remote,0",
]


def _csv_response(rows: list[str] | None = None) -> httpx.Response:
    lines = [_CSV_HEADER] + (rows if rows is not None else _CSV_ROWS)
    return httpx.Response(200, text="\n".join(lines), request=_REQ)


# ── source_name ───────────────────────────────────────────────────────────


def test_source_name():
    assert ExploitDBIngestor().source_name() == "exploitdb"


# ── fetch_updates ─────────────────────────────────────────────────────────


async def test_fetch_groups_rows_by_cve():
    resp = _csv_response()

    with patch("ingestion.exploitdb.get_response_with_retry", new_callable=AsyncMock, return_value=resp):
        results = await _collect(ExploitDBIngestor().fetch_updates(since=None))

    cve_ids = {r.cve_id for r in results}
    assert "CVE-2025-1111" in cve_ids
    assert "CVE-2025-2222" in cve_ids
    assert "CVE-2025-3333" in cve_ids


async def test_fetch_merges_multiple_exploits_for_same_cve():
    resp = _csv_response()

    with patch("ingestion.exploitdb.get_response_with_retry", new_callable=AsyncMock, return_value=resp):
        results = await _collect(ExploitDBIngestor().fetch_updates(since=None))

    cve_1111 = next(r for r in results if r.cve_id == "CVE-2025-1111")
    assert len(cve_1111.raw_data["exploits"]) == 2


async def test_fetch_skips_rows_without_cve():
    resp = _csv_response()

    with patch("ingestion.exploitdb.get_response_with_retry", new_callable=AsyncMock, return_value=resp):
        results = await _collect(ExploitDBIngestor().fetch_updates(since=None))

    cve_ids = {r.cve_id for r in results}
    assert "No CVE" not in str(cve_ids)


async def test_fetch_filters_by_date_when_since_provided():
    resp = _csv_response()
    since = datetime(2025, 1, 20, tzinfo=timezone.utc)

    with patch("ingestion.exploitdb.get_response_with_retry", new_callable=AsyncMock, return_value=resp):
        results = await _collect(ExploitDBIngestor().fetch_updates(since=since))

    cve_ids = {r.cve_id for r in results}
    assert "CVE-2025-2222" in cve_ids  # published 2025-02-01, after cutoff
    assert "CVE-2025-3333" in cve_ids  # published 2025-02-10, after cutoff
    # CVE-2025-1111 still appears (row 10004 is after cutoff), but only with 1 exploit
    # — row 10001 (2025-01-10) was filtered out
    cve_1111 = next(r for r in results if r.cve_id == "CVE-2025-1111")
    assert len(cve_1111.raw_data["exploits"]) == 1


async def test_fetch_returns_empty_for_no_cve_rows():
    resp = _csv_response([
        "99999,exploits/test.py,No vulnerability reference,2025-01-01,tester,linux,remote,0",
    ])

    with patch("ingestion.exploitdb.get_response_with_retry", new_callable=AsyncMock, return_value=resp):
        results = await _collect(ExploitDBIngestor().fetch_updates(since=None))

    assert results == []


# ── _normalize ────────────────────────────────────────────────────────────


def test_normalize_creates_exploit_objects():
    raw = {
        "cve_id": "CVE-2025-1111",
        "exploits": [
            {"id": "10001", "description": "RCE exploit", "date_published": "2025-01-10"},
        ],
    }
    result = ExploitDBIngestor()._normalize(raw)

    assert result.cve_id == "CVE-2025-1111"
    assert result.source == "exploitdb"
    assert len(result.exploits) == 1
    assert result.exploits[0].source == "exploitdb"
    assert result.exploits[0].source_id == "10001"


def test_normalize_builds_exploit_url():
    raw = {
        "cve_id": "CVE-2025-1111",
        "exploits": [{"id": "10001", "description": "test"}],
    }
    result = ExploitDBIngestor()._normalize(raw)

    assert result.exploits[0].url == "https://www.exploit-db.com/exploits/10001"


def test_normalize_parses_exploit_date():
    raw = {
        "cve_id": "CVE-2025-1111",
        "exploits": [{"id": "10001", "date_published": "2025-03-15"}],
    }
    result = ExploitDBIngestor()._normalize(raw)

    assert result.exploits[0].discovered_at is not None
    assert result.exploits[0].discovered_at.year == 2025
    assert result.exploits[0].discovered_at.month == 3


def test_normalize_handles_missing_date():
    raw = {
        "cve_id": "CVE-2025-1111",
        "exploits": [{"id": "10001"}],
    }
    result = ExploitDBIngestor()._normalize(raw)

    assert result.exploits[0].discovered_at is None


def test_normalize_handles_multiple_exploits():
    raw = {
        "cve_id": "CVE-2025-1111",
        "exploits": [
            {"id": "10001", "description": "Exploit A"},
            {"id": "10002", "description": "Exploit B"},
        ],
    }
    result = ExploitDBIngestor()._normalize(raw)

    assert len(result.exploits) == 2
    assert {e.source_id for e in result.exploits} == {"10001", "10002"}
